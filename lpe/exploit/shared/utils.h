#pragma once

#include <Windows.h>
#include <synchapi.h>
#include <handleapi.h>
#include <AccCtrl.h>
#include <AclAPI.h>
#include <TlHelp32.h>

#include <cstring>
#include <cstdarg>
#include <cstdint>
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <winternl.h>

struct IndentWrapper
{

    IndentWrapper()
    {
        size_t curPos = strlen(g_IndentBuffer);
        g_IndentBuffer[curPos] = ' ';
        g_IndentBuffer[curPos + 1] = ' ';
        g_IndentBuffer[curPos + 2] = 0;
    }

    ~IndentWrapper()
    {
        size_t curPos = strlen(g_IndentBuffer);
        g_IndentBuffer[curPos - 2] = 0;
    }

    static inline char g_IndentBuffer[0x100];
};

#define ScopedIndent() IndentWrapper _private_IW_##LINE;

void Print(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    printf(IndentWrapper::g_IndentBuffer);
    vprintf(fmt, args);
    va_end(args);
}

template <typename T, typename A, typename V>
void WritePtr(A addr, V offset, const T& value)
{
    *reinterpret_cast<T*>(reinterpret_cast<uint8_t*>(addr) + static_cast<size_t>(offset)) = value;
}

int64_t FindBytePatternIndex(const uint8_t* sourceBytes, const size_t sourceBytesSize, const uint8_t* bytePattern, const size_t bytePatternSize)
{
    std::vector<uint8_t> sourceVec(sourceBytes, sourceBytes + sourceBytesSize);
    std::vector<uint8_t> patternVec(bytePattern, bytePattern + bytePatternSize);

    auto it = std::search(sourceVec.begin(), sourceVec.end(), patternVec.begin(), patternVec.end());
    if (it == sourceVec.end())
    {
        return -1ll;
    }

    return it - sourceVec.begin();
}; 

bool GrantGroupAccessToObject(const wchar_t* objectName, const wchar_t* groupName, SE_OBJECT_TYPE objectType, DWORD permissions)
{
    PACL pOldDACL = NULL, pNewDACL = NULL;
    EXPLICIT_ACCESS ea;
    PSECURITY_DESCRIPTOR pSD = NULL;

    if (GetNamedSecurityInfo(objectName, objectType, DACL_SECURITY_INFORMATION, NULL, NULL, &pOldDACL, NULL, &pSD) < 0)
    {
        Print("[-] Unable to get named security info for %ls.\n", objectName);
        return false;
    }

    ZeroMemory(&ea, sizeof(ea));
    ea.grfAccessPermissions = permissions;
    ea.grfAccessMode = GRANT_ACCESS;
    ea.grfInheritance = NO_INHERITANCE;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea.Trustee.ptstrName = (LPTSTR)groupName;

    if (SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL) < 0)
    {
        Print("[-] Unable to set descriptor entries for %ls.\n", objectName);
        return false;
    }

    if (SetNamedSecurityInfo((LPWSTR)objectName, objectType, DACL_SECURITY_INFORMATION, NULL, NULL, pNewDACL, NULL) < 0)
    {
        Print("[-] Unable to set named security info for %ls.\n", objectName);
        return false;
    }

    if (pNewDACL)
        LocalFree(pNewDACL);
    if (pSD)
        LocalFree(pSD);

    return true;
}

struct WinEventWrapper
{
    WinEventWrapper(const wchar_t* eventName)
    {
        m_hEvent = CreateEvent(NULL, false, false, eventName);
        GrantGroupAccessToObject(eventName, L"ALL APPLICATION PACKAGES", SE_KERNEL_OBJECT, EVENT_MODIFY_STATE);
        GrantGroupAccessToObject(eventName, L"Everyone", SE_KERNEL_OBJECT, EVENT_MODIFY_STATE);
    }

    bool Wait(uint32_t timeout = 0)
    {
        if (!m_hEvent) return false;
        return WaitForSingleObject(m_hEvent, timeout) == WAIT_OBJECT_0;
    }

    ~WinEventWrapper()
    {
        CloseHandle(m_hEvent);
    }

private:
    HANDLE m_hEvent;
};

LPVOID GetFnAddress(const wchar_t* moduleName, const char* fnName)
{
    bool needFreeLibrary = false;
    HMODULE hModule = GetModuleHandle(moduleName);
    if (!hModule)
    {
        hModule = LoadLibrary(moduleName);
        if (!hModule)
        {
            return (LPVOID)0;
        }
        needFreeLibrary = true;
    }

    FARPROC hFn = GetProcAddress(hModule, fnName);

    if (needFreeLibrary)
    {
        FreeLibrary(hModule);
    }

    return (LPVOID)hFn;
};

DWORD FindProcessPID(const wchar_t* processName, int32_t sessionId = -1)
{
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    DWORD pid = -1;
    if (Process32First(snapshot, &entry))
    {
        while (Process32Next(snapshot, &entry))
        {
            if (_wcsnicmp(entry.szExeFile, processName, sizeof(entry.szExeFile) / sizeof(wchar_t)) == 0)
            {
                DWORD processSessionId = -1;
                if (sessionId == -1 || (ProcessIdToSessionId(entry.th32ProcessID, &processSessionId) && processSessionId == sessionId))
                {
                    pid = entry.th32ProcessID;
                    break;
                }
            }
        }
    }

    CloseHandle(snapshot);
    return pid;
};

DWORD GetCurrentSessionId()
{
    DWORD sessionId = -1;
    ProcessIdToSessionId(GetCurrentProcessId(), &sessionId);
    return sessionId;
}

template <typename Callback>
LPVOID WriteToRemoteProcess(HANDLE hProcess, Callback callback)
{
    LPVOID address = VirtualAllocEx(hProcess, NULL, 0x4000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!address)
    {
        return address;
    }

    if (!callback(hProcess, address))
    {
        VirtualFreeEx(hProcess, address, 0x4000, MEM_FREE);
        return NULL;
    }

    return address;
};

bool CreateRemoteThreadInProcess(HANDLE hProcess, LPVOID parameter, LPVOID threadProc)
{
    DWORD ret = WAIT_FAILED;
    HANDLE hndl = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)threadProc, parameter, NULL, NULL);
    if (hndl)
    {
        ret = WaitForSingleObject(hndl, 30000);
        CloseHandle(hndl);
        hndl = NULL;
    }
    return ret == WAIT_OBJECT_0;
};

template <typename WriteArgsCallback>
bool ExecuteFnInRemoteProcess(const wchar_t* processName, const wchar_t* moduleName, const char* fnName, WriteArgsCallback callback)
{
    DWORD targetProcessPID = FindProcessPID(processName);
    if (targetProcessPID == -1)
    {
        Print("[-] Couldn't find process by the name of %ls\n", processName);
        return false;
    }

    HANDLE processHandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION, FALSE, targetProcessPID);
    if (processHandle == 0)
    {
        Print("[-] Couldn't open target process with desired accesses.\n");
        return false;
    }

    LPVOID argsRemoteAddress = WriteToRemoteProcess(processHandle, callback);
    if (argsRemoteAddress == 0)
    {
        Print("[-] Couldn't write memory to target process\n");
        return false;
    }

    if (!CreateRemoteThreadInProcess(processHandle, argsRemoteAddress, GetFnAddress(moduleName, fnName)))
    {
        Print("[-] CreateRemoteThread failed in target process.\n");
        return false;
    }

    return true;
}

bool CreateRemoteProcess(const wchar_t* commandLine, DWORD flags)
{
    STARTUPINFOW startupInfo = {};
    PROCESS_INFORMATION processInfo = {};
    return CreateProcess(NULL, (LPWSTR)commandLine, NULL, NULL, true, flags, NULL, NULL, &startupInfo, &processInfo);
}

class BinaryStream
{
public:
    BinaryStream() : m_Position(0) {}
    BinaryStream(const std::vector<uint8_t>& buffer) : m_Buffer(buffer), m_Position(0) {}
    BinaryStream(const uint8_t* buffer, size_t size) : m_Buffer(buffer, buffer + size), m_Position(0) {}

    size_t GetSize() const { return m_Buffer.size(); }
    bool CanRead() const { return m_Position < GetSize(); }
    const uint8_t* GetRawBuffer() const { return m_Buffer.data(); }
    uint8_t* GetRawBuffer() { return m_Buffer.data(); }
    const std::vector<uint8_t> GetBuffer() const { return m_Buffer; }

protected:
    std::vector<uint8_t> m_Buffer;
    size_t m_Position;

public:
    template <typename T>
    T Read()
    {
        if (m_Position + sizeof(T) > GetSize())
        {
            return static_cast<T>(0);
        }

        T returnValue;
        ReadRawData(reinterpret_cast<uint8_t*>(&returnValue), sizeof(T));
        return returnValue;
    }

    std::vector<uint8_t> ReadAll() const
    {
        return m_Buffer;
    }

    void Resize(size_t length)
    {
        m_Buffer.resize(length);
    }

    template <typename T>
    BinaryStream& Write(const T& value)
    {
        WriteRawData(reinterpret_cast<const uint8_t*>(&value), sizeof(T));
        return *this;
    }

    template <>
    BinaryStream& Write<std::vector<uint8_t>>(const std::vector<uint8_t>& value)
    {
        WriteRawData(value.data(), value.size());
        return *this;
    }

    bool ReadRawData(uint8_t* destination, size_t size)
    {
        if (m_Position + size <= GetSize())
        {
            memcpy(destination, &m_Buffer[m_Position], size);
            m_Position += size;
            return true;
        }

        return false;
    }

    void WriteRawData(const uint8_t* source, size_t size)
    {
        auto curSize = GetSize();
        m_Buffer.resize(curSize + size);
        memcpy(m_Buffer.data() + curSize, source, size);
    }
};

